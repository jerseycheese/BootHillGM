/**
 * Hook for checking narrative text for decision triggers and generating AI decisions
 */
import { useCallback } from 'react';
import { addNarrativeHistory } from '../../actions/narrativeActions';
import { DecisionImportance, PlayerDecision } from '../../types/narrative.types';
import { NarrativeContextValue } from './types';
import { GameState } from '../../types/gameState';
import { initialCharacterState } from '../../types/state/characterState';
import { initialInventoryState } from '../../types/state/inventoryState';
import { initialJournalState } from '../../types/state/journalState';
import { initialUIState } from '../../types/state/uiState';
import { CombatState } from '../../types/state';
// Removed unused import: Character

/**
 * Hook that provides functionality for checking narrative for decision triggers
 * and generating AI decisions.
 * 
 * @param context The narrative context
 * @param presentPlayerDecision Function to present decisions to the player
 * @returns Functions for checking and triggering decisions
 */
export function useDecisionTriggering(
  context: NarrativeContextValue,
  presentPlayerDecision: (decision: PlayerDecision) => void
) {
  const { state, dispatch } = context;

  /**
   * Helper function to ensure narrative state is fresh before generating decisions
   * 
   * This function handles the state update to force a refresh before
   * decision generation to fix the stale context issue (#210).
   */
  const ensureFreshState = useCallback(async () => {
    // Force a state update to ensure we have the freshest state
    // Instead of using lastRefreshed which isn't in the type,
    // we can simply use an empty object to trigger the update
    dispatch({
      type: 'UPDATE_NARRATIVE',
      payload: {}  // Empty object is valid and will trigger a state update
    });

    // Wait a small delay to ensure state has updated
    await new Promise<void>(resolve => {
      setTimeout(() => resolve(), 50);
    });

    // Return the current state after refresh
    return state;
  }, [state, dispatch]);

  /**
   * Check if the narrative contains triggers for decisions
   * 
   * This function analyzes narrative text for keywords that might indicate
   * a decision point. In a production implementation, this would use AI
   * to identify appropriate decision points.
   * 
   * @param narrativeText - The current narrative text to analyze
   * @returns Boolean indicating if a decision was triggered
   */
  const checkForDecisionTriggers = useCallback((narrativeText: string) => {
    // For now, just check for some keywords that might indicate a decision point
    // In a real implementation, this would be handled by the AI service
    const keywords = [
      'decide', 'choice', 'choose', 'option', 'what will you do', 
      'what do you do', 'your move', 'your turn'
    ];
    
    const lowerText = narrativeText.toLowerCase();
    const shouldTrigger = keywords.some(keyword => 
      lowerText.includes(keyword.toLowerCase())
    );
    
    if (shouldTrigger && !state.currentDecision) {
      // Create a simple gameplay-triggered decision
      // In a real implementation, this would be generated by the AI
      const testDecision = {
        id: `narrative-decision-${Date.now()}`,
        prompt: 'How do you respond?',
        timestamp: Date.now(),
        options: [
          { 
            id: 'option1', 
            text: 'Cautiously investigate the situation',
            impact: 'You might learn valuable information but could place yourself at risk.'
          },
          { 
            id: 'option2', 
            text: 'Take immediate action',
            impact: 'Bold moves can yield rewards but might have unforeseen consequences.'
          },
          { 
            id: 'option3', 
            text: 'Step back and observe',
            impact: 'Playing it safe lets you gather more information but may mean missing an opportunity.'
          }
        ],
        context: 'The narrative seems to be leading to a decision point...',
        importance: 'moderate' as DecisionImportance,
        characters: ['Player Character'],
        aiGenerated: false
      };
      
      // Present the decision
      presentPlayerDecision(testDecision);
      
      return true;
    }
    
    return false;
  }, [state.currentDecision, presentPlayerDecision]);

  /**
   * Trigger an AI-generated decision with specific context
   * 
   * This function uses the enhanced decision generator to create a contextually
   * appropriate decision based on the most recent narrative state.
   * 
   * @param context - Additional narrative context (optional)
   * @param importance - Optional importance level for the decision
   * @returns Boolean indicating if the decision was successfully triggered
   */
  const triggerAIDecision = useCallback(async (context?: string, importance: DecisionImportance = 'moderate') => {
    if (state.currentDecision) {
      return false;
    }
    
    try {
      // First, ensure we have fresh state (fix for issue #210)
      await ensureFreshState();
      
      // Import the enhanced decision generator - dynamic import to avoid circular dependencies
      const { generateEnhancedDecision, setDecisionGenerationMode } = await import('../../utils/contextualDecisionGenerator.enhanced');
      
      // Force AI mode to ensure context awareness
      setDecisionGenerationMode('ai');
      
      // Create a player reference that satisfies TypeScript
      // Removed unused refs: playerRef, opponentRef
      
      // Create a complete GameState object to satisfy the type requirements
      const gameState: GameState = {
        currentPlayer: 'player',
        npcs: [],
        location: null,
        inventory: initialInventoryState,
        quests: [],
        gameProgress: 0,
        character: initialCharacterState,
        combat: {} as CombatState,
        journal: initialJournalState,
        narrative: state,
        ui: initialUIState,
        suggestedActions: [],
        isClient: true,
        // Removed obsolete getters (player, opponent, isCombatActive)
      };
      
      // If additional context was provided, add it to the narrative
      if (context) {
        // Add the context to the narrative history for better context awareness
        dispatch(addNarrativeHistory(`Game Master: ${context}`));
        
        // Refresh state again after adding context
        await ensureFreshState();
      }
      
      // Generate a decision using the enhanced generator with most current state
      const decision = await generateEnhancedDecision(
        gameState,
        state.narrativeContext,
        undefined, // Let the generator determine location from state
        true // Force generation
      );
      
      // If we got a decision, present it
      if (decision) {
        presentPlayerDecision(decision);
        return true;
      }
      
      return false;
    } catch (error) {
      console.error('Error generating AI decision:', error);
      
      // Fallback to a template decision if AI generation fails
      const fallbackDecision = {
        id: `fallback-decision-${Date.now()}`,
        prompt: 'What would you like to do next?',
        timestamp: Date.now(),
        options: [
          { 
            id: `fallback-opt1-${Date.now()}`, 
            text: 'Continue exploring',
            impact: 'You may discover more about your surroundings.'
          },
          { 
            id: `fallback-opt2-${Date.now()}`, 
            text: 'Take a more cautious approach',
            impact: 'Being careful might reveal hidden dangers or opportunities.'
          },
          { 
            id: `fallback-opt3-${Date.now()}`, 
            text: 'Search for clues',
            impact: 'You might find something important to your quest.'
          }
        ],
        context: context || 'Continuing your adventure...',
        importance: importance,
        characters: [],
        aiGenerated: true
      };
      
      presentPlayerDecision(fallbackDecision);
      return true;
    }
  }, [state, dispatch, presentPlayerDecision, ensureFreshState]);

  return {
    checkForDecisionTriggers,
    triggerAIDecision,
    ensureFreshState
  };
}